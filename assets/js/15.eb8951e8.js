(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{147:function(t,a,s){"use strict";s.r(a);var n=s(0),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("并发锁这一块也是面试的重点")])]),t._v(" "),s("ol",[s("li",[t._v("java.util.concurrent.locks")])]),t._v(" "),s("h3",{attrs:{id:"synchronized-隐式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-隐式锁"}},[t._v("#")]),t._v(" Synchronized --隐式锁")]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("用法:\n修饰 实例方法: 锁为当前实例\n修饰 静态方法: 锁为当前类对象\n修饰 代码块: 可以手动指定加锁对象")])])]),t._v(" "),s("blockquote",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("底层原理:\n加锁其实就是获取当前对象的是监视器,每个对象都关联着一个监视器,加锁的过程就是拿到对象的监视器,将监视器中的计数值由0变为1,此时如果其他线程要获取当前对象的监视器,就会被阻塞,直到正在执行的线程执行完毕,而无论这个方法是正常结束还是异常结束,都会释放监视器,(将监视器中的计数值变为0),这时其他线程可以重新获取监视器.监视器对象存在于每个Java对象的"),s("strong",[t._v("对象头")]),t._v("中(存储的指针的指向),同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因")])])]),t._v(" "),s("p",[t._v("同步代码块:\n使用的是monitorenter 和 monitorexit 指令,在执行代码块的开始和结束的位置加上这两条指令,同时在后面还要加上 monitorexit指令,用于异常结束时被执行的释放monitor的指令。")]),t._v(" "),s("p",[t._v("实例方法: 同步是隐式的,JVM可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志区分一个方法是否同步方法当方法调用时,调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了执行线程将先持有监视器,然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放监视器。")]),t._v(" "),s("blockquote",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("JVM对synchronized优化\n锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级")])])]),t._v(" "),s("p",[t._v("偏向锁: 它是一种针对加锁操作的优化手段,在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁的代价而引入偏向锁.")]),t._v(" "),s("p",[t._v("轻量级锁: 存在线程竞争的时候,偏向锁升级为轻量级锁,轻量级锁所适应的场景是线程交替执行同步块的场合,如果出现不同时间同一时间争取锁的场景,锁就会升级成重量级锁.")]),t._v(" "),s("p",[t._v("自旋锁: 在大多数情况下，线程持有锁的时间都不会太长,如果直接挂起操作系统层面的线程可能会得不偿失,需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高.")]),t._v(" "),s("p",[t._v("锁消除: 这个了解太少,大致的理解就是去除不可能存在共享资源竞争的锁,\n举个例子:")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//因此sb属于不可能共享的资源,JVM会自动消除内部的锁")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StringBuffer")]),t._v(" sb "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StringBuffer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        sb"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("str1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("str2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("总结一下,就是尽量消除加锁的操作带来的性能消耗,避免频繁的用户态到核心态的切换,这一切对你都是无感知的;")]),t._v(" "),s("h3",{attrs:{id:"reetrantlock-显示锁-基于aqs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reetrantlock-显示锁-基于aqs"}},[t._v("#")]),t._v(" ReetrantLock  -- 显示锁 基于AQS")]),t._v(" "),s("ol",[s("li",[t._v("介绍")])]),t._v(" "),s("blockquote",[s("p",[t._v("锁的持有和释放都必须由我们手动编写,作用与Synchronized关键字相当，但比Synchronized更加灵活,重入锁支持一个线程对资源重复加锁，同时也支持公平锁与非公平锁,公平锁就是先请求的锁的总是先获取锁,根据请求的顺序获取锁,非公平锁是没有顺序的,每个线程都有机会竞争")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("AQS原理")])]),t._v(" "),s("blockquote",[s("p",[t._v("ReentrantLock其内部实现了3个类，分别是Sync、NoFairSync以及FairSync类，其中Sync继承自AQS，实现了释放锁的模板方法tryRelease(int)，而NoFairSync和FairSync都继承自Sync，实现不同获取锁的方法tryAcquire(int)。ReentrantLock的所有方法实现几乎都间接调用了这3个类，因此当我们在使用ReentrantLock时，大部分使用都是在间接调用AQS同步器中的方法")])]),t._v(" "),s("h3",{attrs:{id:"aqs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aqs"}},[t._v("#")]),t._v(" AQS")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20170722111303134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:""}})]),t._v(" "),s("p",[t._v("AbstractQueuedSynchronizer又称为队列同步器(后面简称AQS)，它是用来构建锁或其他同步组件的基础框架，内部通过一个int类型的成员变量state来表示当前线程是否持有锁,当state = 0时，则说明没有任何线程获取锁，当state=1时，则说明有线程目前持有锁，其他线程必须加入同步队列进行等待，AQS内部通过内部类Node构成FIFO的同步队列来完成线程获取锁的排队工作，同时利用内部类ConditionObject构建等待队列，当Condition调用wait()方法后，线程将会加入等待队列中，而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中进行锁竞争。注意这里涉及到两种队列")]),t._v(" "),s("p",[t._v("等待队列: 当Condition调用wait()方法后，线程将会加入等待队列中\n同步队列(双向链表): 当线程请求锁而等待的后将加入同步队列等待")]),t._v(" "),s("p",[t._v("通常有两种实现模式\n共享模式: 同一时间段一个锁允许多条线程对共享资源进行操作(信号量)\n独占模式: 同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待")]),t._v(" "),s("h3",{attrs:{id:"非公平锁的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非公平锁的实现"}},[t._v("#")]),t._v(" 非公平锁的实现")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20170720082720370?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:""}})]),t._v(" "),s("ol",[s("li",[s("p",[t._v("获取锁的过程\n首先尝试进行CAS操作将state值由0变为1,成功则将当前线程设置为OwnerThread,失败后又做了两件事,一是尝试再次获取同步状态，如果获取成功则将当前线程设置为OwnerThread，否则失败，二是判断当前线程current是否为OwnerThread，如果是则属于重入锁，state自增1，并获取锁成功，返回true，反之失败，返回false")])]),t._v(" "),s("li",[s("p",[t._v("加入队列的过程\n在尝试获取锁失败后,会尝试加入同步队列,这时有两种情况,一是队列还没有初始化,如果没有初始化,则创建新结点并设置头结点，二是队列已存在，则将新结点node添加到队尾。\n添加到同步队列后，结点就会进入一个自旋过程,当节点为头节点时才尝试获取锁,如果获取到锁,则从同步队列中移除")])]),t._v(" "),s("li",[s("p",[t._v("解锁的实现")])])]),t._v(" "),s("h3",{attrs:{id:"公平锁的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#公平锁的实现"}},[t._v("#")]),t._v(" 公平锁的实现")]),t._v(" "),s("p",[t._v("在获取锁的时，公平锁的获取顺序是完全遵循时间上的FIFO规则，也就是说先请求的线程一定会先获取锁，后来的线程肯定需要排队\n不同是在使用CAS设置尝试设置state值前，判断同步队列是否存在结点，如果存在必须先执行完同步队列中结点的线程，当前线程进入等待状态。这就是非公平锁与公平锁最大的区别，即公平锁在线程请求到来时先会判断同步队列是否存在结点，如果存在先执行同步队列中的结点线程，当前线程将封装成node加入同步队列等待。而非公平锁呢，当线程请求到来时，不管同步队列是否存在线程结点，直接尝试获取同步状态，获取成功直接访问共享资源，")]),t._v(" "),s("h1",{attrs:{id:"按照锁的种类去分吧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#按照锁的种类去分吧"}},[t._v("#")]),t._v(" 按照锁的种类去分吧")]),t._v(" "),s("p",[t._v("正如代码所示，我们通过两者Condition对象单独控制消费线程与生产消费，这样可以避免消费线程在唤醒线程时唤醒的还是消费线程，如果是通过synchronized的等待唤醒机制实现的话，就可能无法避免这种情况，毕竟同一个锁，对于synchronized关键字来说只能有一组等待唤醒队列，而不能像Condition一样，同一个锁拥有多个等待队列")]),t._v(" "),s("h2",{attrs:{id:"无锁操作-cas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无锁操作-cas"}},[t._v("#")]),t._v(" 无锁操作 CAS")]),t._v(" "),s("ol",[s("li",[t._v("CAS的全称是Compare And Swap 即比较交换")])]),t._v(" "),s("blockquote",[s("p",[t._v("操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20170701155737036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:"CAS原理"}})]),t._v(" "),s("p",[t._v("解决ABA问题 -- 加入序列号或者时间戳,保证当前改变是唯一")]),t._v(" "),s("p",[t._v("java.util.concurrent.atomic包下的所有的CAS都是调用Unsafe类来进行操作,该类中都是native方法(外部的C语言的方法),这些方法操作可以像C的指针一样直接操作内存,进而在操作系统的层面上实现CAS.")]),t._v(" "),s("h3",{attrs:{id:"semaphore-共享锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#semaphore-共享锁"}},[t._v("#")]),t._v(" Semaphore - 共享锁")]),t._v(" "),s("p",[t._v("共享锁模式允许同一个时刻多个线程可获取锁,信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量.")]),t._v(" "),s("p",[t._v("获取许可:\nacquire():")]),t._v(" "),s("p",[t._v("释放许可:\nrelease();")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("公平锁的实现\n当我们调用Semaphore的acquire()方法后，执行过程是这样的，当一个线程请求到来时，如果state值代表的许可数足够使用，那么请求线程将会获得同步状态即对共享资源的访问权，并更新state的值(一般是对state值减1)，但如果state值代表的许可数已为0，则请求线程将无法获取同步状态，线程将被加入到同步队列并阻塞，直到其他线程释放同步状态(一般是对state值加1)才可能获取对共享资源的访问权")])]),t._v(" "),s("li",[s("p",[t._v("非公平锁的实现\n在尝试获取同步状态前，先调用了hasQueuedPredecessors()方法判断同步队列中是否存在结点，如果存在则返回-1，即将线程加入同步队列等待。从而保证先到来的线程请求一定会先执行，也就是所谓的公平锁。至于其他操作，与前面分析的非公平锁一样。")])])]),t._v(" "),s("p",[t._v("AQS中通过state值来控制对共享资源访问的线程数，每当线程请求同步状态成功，state值将会减1，如果超过限制数量的线程将被封装共享模式的Node结点加入同步队列等待，直到其他执行线程释放同步状态，才有机会获得执行权，而每个线程执行完成任务释放同步状态后，state值将会增加1，这就是共享锁的基本实现模型")]),t._v(" "),s("h2",{attrs:{id:"condition-不经常用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#condition-不经常用"}},[t._v("#")]),t._v(" Condition 不经常用")]),t._v(" "),s("p",[t._v("在并发编程中，每个Java对象都存在一组监视器方法，如wait()、notify()以及notifyAll()方法，通过这些方法，我们可以实现线程间通信与协作（也称为等待唤醒机制")]),t._v(" "),s("p",[t._v("await()方法主要做了3件事，一是调用addConditionWaiter()方法将当前线程封装成node结点加入等待队列，二是调用fullyRelease(node)方法释放同步状态并唤醒后继结点的线程。三是调用isOnSyncQueue(node)方法判断结点是否在同步队列中，注意是个while循环，如果同步队列中没有该结点就直接挂起该线程，需要明白的是如果线程被唤醒后就调用acquireQueued(node, savedState)执行自旋操作争取锁，即当前线程结点从等待队列转移到同步队列并开始努力获取锁")]),t._v(" "),s("p",[t._v("这里signal()方法做了两件事，一是判断当前线程是否持有独占锁，没有就抛出异常，从这点也可以看出只有独占模式先采用等待队列，而共享模式下是没有等待队列的，也就没法使用Condition。二是唤醒等待队列的第一个结点，即执行doSignal(first)")]),t._v(" "),s("p",[t._v("signal()被调用后，先判断当前线程是否持有独占锁，如果有，那么唤醒当前Condition对象中等待队列的第一个结点的线程，并从等待队列中移除该结点，移动到同步队列中，如果加入同步队列失败，那么继续循环唤醒等待队列中的其他结点的线程，如果成功加入同步队列，那么如果其前驱结点是否已结束或者设置前驱节点状态为Node.SIGNAL状态失败，则通过LockSupport.unpark()唤醒被通知节点代表的线程，到此signal()任务完成")])])}),[],!1,null,null,null);a.default=e.exports}}]);