(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{149:function(t,e,a){"use strict";a.r(e);var n=a(0),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("目前国内的公司几乎都在用Dubbo,也基本是必问的,但是问的点其实就是那么几个")])]),t._v(" "),a("h3",{attrs:{id:"为什么要用dubbo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用dubbo"}},[t._v("#")]),t._v(" 为什么要用Dubbo?")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("什么是Dubbo")])])]),t._v(" "),a("blockquote",[a("p",[t._v("Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目,主要用于分布式领域")])]),t._v(" "),a("blockquote",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("为什么要用 Dubbo")])])]),t._v(" "),a("blockquote",[a("p",[t._v("随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进,当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求\nhttps://www.cnblogs.com/winner-0715/p/5847638.html")])]),t._v(" "),a("h3",{attrs:{id:"dubbo-详细执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-详细执行流程"}},[t._v("#")]),t._v(" Dubbo 详细执行流程")]),t._v(" "),a("blockquote",[a("p",[t._v("提到Dubbo就想到生产者和消费者\n首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。")])]),t._v(" "),a("h3",{attrs:{id:"dubbo的序列化是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dubbo的序列化是怎样的"}},[t._v("#")]),t._v(" Dubbo的序列化是怎样的?")]),t._v(" "),a("h3",{attrs:{id:"dubbo-如何异步转同步的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-如何异步转同步的"}},[t._v("#")]),t._v(" Dubbo 如何异步转同步的")]),t._v(" "),a("p",[t._v("Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sayHello")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将参数存储到 Object 数组中")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" arrobject "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" object "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("handler"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("invoke")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" methods"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arrobject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回调用结果")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("InvokerInvocationHandler 中的 invoker 成员变量类型为 MockClusterInvoker，MockClusterInvoker 内部封装了服务降级逻辑")]),t._v(" "),a("p",[t._v("com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker#doInvoke\n上面的代码包含了 Dubbo 对同步和异步调用的处理逻辑，搞懂了上面的代码，会对 Dubbo 的同步和异步调用方式有更深入的了解")]),t._v(" "),a("p",[t._v("proxy0#sayHello(String)\n—> InvokerInvocationHandler#invoke(Object, Method, Object[])\n—> MockClusterInvoker#invoke(Invocation)\n—> AbstractClusterInvoker#invoke(Invocation)\n—> FailoverClusterInvoker#doInvoke(Invocation, List<Invoker"),a("T",[t._v(">, LoadBalance)\n—> Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用\n—> ListenerInvokerWrapper#invoke(Invocation)\n—> AbstractInvoker#invoke(Invocation)\n—> DubboInvoker#doInvoke(Invocation)\n—> ReferenceCountExchangeClient#request(Object, int)\n—> HeaderExchangeClient#request(Object, int)\n—> HeaderExchangeChannel#request(Object, int)\n—> AbstractPeer#send(Object)\n—> AbstractClient#send(Object, boolean)\n—> NettyChannel#send(Object, boolean)\n—> NioClientSocketChannel#write(Object)\n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务")])],1),t._v(" "),a("h3",{attrs:{id:"测试环境-哈哈哈哈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试环境-哈哈哈哈"}},[t._v("#")]),t._v(" 测试环境 哈哈哈哈")]),t._v(" "),a("p",[t._v("点对点直连服务提供方，用于测试\t\n参数验证，JSR303验证框架集成\t\n泛化调用，无需业务接口类进行远程调用，用于测试平台，开放网关桥接等\n伪造返回结果，可在失败时执行，或直接执行，用于服务降级\t\nJTA/XA三阶段提交事务")]),t._v(" "),a("p",[t._v("方法级优先，接口级次之，全局配置再次之。\n如果级别一样，则消费方优先，提供方次之")]),t._v(" "),a("p",[t._v("建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置")]),t._v(" "),a("p",[t._v("在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。")]),t._v(" "),a("p",[t._v("在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。\n随机\n轮询\n最少活跃数\n相同参数的请求总是发到同一提供者")]),t._v(" "),a("p",[a("strong",[t._v("线程模型 不太懂耦")])]),t._v(" "),a("p",[t._v("当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。")]),t._v(" "),a("p",[t._v("可以按照以下的步骤进行版本迁移：")]),t._v(" "),a("p",[t._v("在低压力时间段，先升级一半提供者为新版本\n再将所有消费者升级为新版本\n然后将剩下的一半提供者升级为新版本")]),t._v(" "),a("p",[t._v("泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过 GenericService 调用所有服务实现。")]),t._v(" "),a("p",[t._v("RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息")]),t._v(" "),a("p",[t._v("可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递")]),t._v(" "),a("p",[a("strong",[t._v("dubbo 异步调用方式 不懂")])]),t._v(" "),a("p",[t._v("本地存根")]),t._v(" "),a("p",[a("strong",[t._v("本地伪装")]),t._v(" 这个比较骚,可以用在日常生活中")]),t._v(" "),a("p",[t._v("mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。\n还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响")]),t._v(" "),a("p",[t._v("优雅停机")]),t._v(" "),a("p",[t._v("线程模型是fixed")]),t._v(" "),a("p",[t._v("在 Provider 端尽量多配置 Consumer 端属性")]),t._v(" "),a("p",[t._v("http://dubbo.apache.org/zh-cn/docs/dev/design.html"),a("br"),t._v("\nhttp://dubbo.apache.org/zh-cn/docs/dev/SPI.html")]),t._v(" "),a("h2",{attrs:{id:"解析服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解析服务"}},[t._v("#")]),t._v(" 解析服务")]),t._v(" "),a("p",[t._v("基于 dubbo.jar 内的 META-INF/spring.handlers 配置，Spring 在遇到 dubbo 名称空间时，会回调 DubboNamespaceHandler。")]),t._v(" "),a("p",[t._v("所有 dubbo 的标签，都统一用 DubboBeanDefinitionParser 进行解析，基于一对一属性映射，将 XML 标签解析为 Bean 对象。")]),t._v(" "),a("p",[t._v("在 ServiceConfig.export() 或 ReferenceConfig.get() 初始化时，将 Bean 对象转换 URL 格式，所有 Bean 属性转成 URL 的参数。")]),t._v(" "),a("p",[t._v("然后将 URL 传给 协议扩展点，基于扩展点的 扩展点自适应机制，根据 URL 的协议头，进行不同协议的服务暴露或引用。")]),t._v(" "),a("h2",{attrs:{id:"暴露服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#暴露服务"}},[t._v("#")]),t._v(" 暴露服务")]),t._v(" "),a("h2",{attrs:{id:"扩展点的实现-重点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展点的实现-重点"}},[t._v("#")]),t._v(" 扩展点的实现 (重点))")]),t._v(" "),a("p",[t._v("Java SPI 实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。")]),t._v(" "),a("p",[t._v("严格约定WARN、ERROR级别记录的内容")]),t._v(" "),a("p",[t._v("WARN 表示可以恢复的问题，无需人工介入。\nERROR 表示需要人工介入问题。\n有了这样的约定，监管系统发现日志文件的中出现 ERROR 字串就报警，又尽量减少了发生。过多的报警会让人疲倦，使人对报警失去警惕性，使 ERROR 日志失去意义。再辅以人工定期查看 WARN 级别信息，以评估系统的“亚健康”程度。")]),t._v(" "),a("h2",{attrs:{id:"暴露服务-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#暴露服务-2"}},[t._v("#")]),t._v(" 暴露服务")]),t._v(" "),a("p",[t._v("org.springframework.context.support.AbstractApplicationContext#finishRefresh")]),t._v(" "),a("ol",[a("li",[t._v("ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷新事件后执行服务导出操作")]),t._v(" "),a("li",[t._v("分别是配置检查，以及 URL 装配。")])]),t._v(" "),a("p",[t._v("检测 "),a("a",{attrs:{href:"dubbo:service"}},[t._v("dubbo:service")]),t._v(" 标签的 interface 属性合法性，不合法则抛出异常\n检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试从其他配置类对象中获取相应的实例。\n检测并处理泛化服务和普通服务类\n检测本地存根配置，并进行相应的处理\n对 ApplicationConfig、RegistryConfig 等配置类进行检测，为空则尝试创建，若无法创建则抛出异常\n3. 组装url URL 之于 Dubbo，犹如水之于鱼，非常重要\n加载所有的注册中心\n暴露协议,暴露端口")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("dubbo"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("172.18")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v(".97")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v(".51")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20880")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("com"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("souche"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shield"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("srp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("api"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("service"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("admin"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("extra"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DepartmentAdminApiService")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("application"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("souche"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("shield"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("srp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("export"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("token"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("souche_http_token"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("dubbo"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.6")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v(".8")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("export"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("generic"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("com"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("souche"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shield"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("srp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("api"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("service"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("admin"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("extra"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DepartmentAdminApiService")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("pid"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("41920")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("revision"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.5")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v(".2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("SNAPSHOT"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("side"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("provider"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("timestamp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1576755352362")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("上面的代码首先是将一些信息，比如版本、时间戳、方法名以及各种配置对象的字段信息放入到 map 中，map 中的内容将作为 URL 的查询字符串。构建好 map 后，紧接着是获取上下文路径、主机名以及端口号等信息。最后将 map 和主机名等数据传给 URL 构造方法创建 URL 对象。需要注意的是，这里出现的 URL 并非 java.net.URL，而是 com.alibaba.dubbo.common.URL。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("服务导出分为导出到本地 (JVM)，和导出到远程\nInvoker 是由 ProxyFactory 创建而来，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory\n制作代理\n4.1 导出服务到本地 创建代理暴露")]),t._v(" "),a("li",[t._v("服务暴露  openServer(url)")]),t._v(" "),a("li",[t._v("服务注册 RegistryProtocol.export")]),t._v(" "),a("li",[t._v("开启netty 在同一台机器上（单网卡），同一个端口上仅允许启动一个服务器实例。若某个端口上已有服务器实例，此时则调用 reset 方法重置服务器的一些配置")]),t._v(" "),a("li",[t._v("ExchangeServer")])]),t._v(" "),a("h2",{attrs:{id:"引用服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用服务"}},[t._v("#")]),t._v(" 引用服务")]),t._v(" "),a("h2",{attrs:{id:"服务调用过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务调用过程"}},[t._v("#")]),t._v(" 服务调用过程")]),t._v(" "),a("p",[t._v("比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤\n首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析")]),t._v(" "),a("p",[t._v("同步调用方式:(默认)\n异步调用方式:")]),t._v(" "),a("p",[t._v("上面的代码包含了 Dubbo 对同步和异步调用的处理逻辑，搞懂了上面的代码，会对 Dubbo 的同步和异步调用方式有更深入的了解。Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法")]),t._v(" "),a("p",[t._v("proxy0#sayHello(String)\n—> InvokerInvocationHandler#invoke(Object, Method, Object[])\n—> MockClusterInvoker#invoke(Invocation)\n—> AbstractClusterInvoker#invoke(Invocation)\n—> FailoverClusterInvoker#doInvoke(Invocation, List<Invoker"),a("T",[t._v(">, LoadBalance)\n—> Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用\n—> ListenerInvokerWrapper#invoke(Invocation)\n—> AbstractInvoker#invoke(Invocation)\n—> DubboInvoker#doInvoke(Invocation)\n—> ReferenceCountExchangeClient#request(Object, int)\n—> HeaderExchangeClient#request(Object, int)\n—> HeaderExchangeChannel#request(Object, int)\n—> AbstractPeer#send(Object)\n—> AbstractClient#send(Object, boolean)\n—> NettyChannel#send(Object, boolean)\n—> NioClientSocketChannel#write(Object)\n服务方发送请求\n请求编码 (Dubbo数据包部分),封装")])],1),t._v(" "),a("p",[t._v("提供方接受请求\n前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。所以在进行后续的分析之前，我们先来看一下数据解码过程")]),t._v(" "),a("ol",[a("li",[t._v("数据包解码\nExchangeCodec-》 DubboCodec -》 DecodeableRpcInvocation\n可将调用方法名、attachment、以及调用参数解析出来")]),t._v(" "),a("li",[t._v("封装成Request\n解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给 NettyServer、MultiMessageHandler、HeartbeatHandler 以及 AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将 Runnable 放入线程池中执行后续的调用逻辑")])]),t._v(" "),a("p",[t._v("NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)\n—> AbstractPeer#received(Channel, Object)\n—> MultiMessageHandler#received(Channel, Object)\n—> HeartbeatHandler#received(Channel, Object)\n—> AllChannelHandler#received(Channel, Object)\n—> ExecutorService#execute(Runnable)"),a("br"),t._v("\nDubbo 将底层通信框架中接收请求的线程称为 IO 线程")]),t._v(" "),a("p",[t._v("2.5.1 响应数据解码\n，Dubbo 会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上\n答案是通过调用编号")])])}),[],!1,null,null,null);e.default=s.exports}}]);