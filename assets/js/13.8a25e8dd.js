(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{142:function(t,e,r){"use strict";r.r(e);var o=r(0),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("blockquote",[r("p",[t._v("这个也是面试问烂的,细心准备以下\n这块在面试中被问到的点就是 IOC 和 AOP,面试官看你不错")])]),t._v(" "),r("h3",{attrs:{id:"_1-谈谈你所理解的ioc-https-www-cnblogs-com-zrtqsk-p-3735273-html"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-谈谈你所理解的ioc-https-www-cnblogs-com-zrtqsk-p-3735273-html"}},[t._v("#")]),t._v(" 1. 谈谈你所理解的IOC https://www.cnblogs.com/zrtqsk/p/3735273.html")]),t._v(" "),r("p",[t._v("首先这种问题的答案,问一万个人一万个人不同,每个人对Spring的理解都是不一样的,这个问题从以下几个点来回答以下")]),t._v(" "),r("blockquote",[r("ol",[r("li",[t._v("什么是依赖注入")])])]),t._v(" "),r("blockquote",[r("p",[t._v("依赖注入（DI）是一个过程，通过该过程，对象仅通过构造函数参数，工厂方法的参数或在构造或创建对象实例后在对象实例上设置的属性来定义其依赖关系（即，与它们一起工作的其他对象）。对象的创建从工厂方法返回。然后，容器在创建bean时注入那些依赖项。")])]),t._v(" "),r("blockquote",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("如何实现依赖注入")])])]),t._v(" "),r("blockquote",[r("p",[t._v("对于Spring来说最重要的两个类,BeanFactory 和 ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。可以说BeanFactory是Spring内部使用的容器,而ApplicationContext包含了BeanFactory的所有功能,与Spring的AOP功能轻松集成,Spring的依赖入住就是通过这两个类实现的.")])]),t._v(" "),r("p",[t._v("其实上面这个是废话,面试官肯定不满意,你就接着说")]),t._v(" "),r("blockquote",[r("ol",{attrs:{start:"3"}},[r("li",[t._v("见Bean的生命周期")])])]),t._v(" "),r("h3",{attrs:{id:"_2-bean-的生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-bean-的生命周期"}},[t._v("#")]),t._v(" 2. Bean 的生命周期")]),t._v(" "),r("p",[t._v("其实这个问题,主要考验的你是,知不知道IOC的大致流程, 看你知不知道那几个扩展点")]),t._v(" "),r("blockquote",[r("ol",[r("li",[t._v("分为两个过程")])])]),t._v(" "),r("ol",[r("li",[t._v("实例化")]),t._v(" "),r("li",[t._v("初始化")])]),t._v(" "),r("p",[r("img",{attrs:{src:"http://images.51cto.com/files/uploadimg/20110419/0930070.png",alt:"生命周期"}})]),t._v(" "),r("blockquote",[r("p",[t._v("实例化前面就是\n1、Bean自身的方法　　：　　这个包括了Bean本身调用的方法和通过配置文件中"),r("bean",[t._v("的init-method和destroy-method指定的方法")])],1)]),t._v(" "),r("p",[t._v("2、Bean级生命周期接口方法　　：　　这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法")]),t._v(" "),r("p",[t._v("3、容器级生命周期接口方法　　：　　这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。")]),t._v(" "),r("p",[t._v("4、工厂后处理器接口方法　　：　　这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用")]),t._v(" "),r("blockquote",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("两个扩展点\nBeanFactoryPostProcessor\nBeanPostProcessor\n"),r("img",{attrs:{src:"https://images2018.cnblogs.com/blog/717817/201805/717817-20180522141553606-1691095215.png",alt:""}})])])]),t._v(" "),r("h3",{attrs:{id:"_3-谈谈你所理解的aop-https-blog-csdn-net-wyl6019-article-details-80136000"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-谈谈你所理解的aop-https-blog-csdn-net-wyl6019-article-details-80136000"}},[t._v("#")]),t._v(" 3. 谈谈你所理解的Aop https://blog.csdn.net/wyl6019/article/details/80136000")]),t._v(" "),r("blockquote",[r("ol",[r("li",[t._v("什么是Aop?")])])]),t._v(" "),r("blockquote",[r("p",[t._v("AOP是对面向对象编程的补充，它也提供了模块化。在面向对象编程中，我们的关注点是对象,而在AOP我们的关注点是切面。这样我们就可以集中处理，比如每个系统都有日志和事务,但是这个和业务逻辑没有太大关系。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高,通常用于事务管理、权限、日志、安全等。")])]),t._v(" "),r("blockquote",[r("ol",{attrs:{start:"2"}},[r("li",[t._v("具体使用方式?\n切面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。")])])]),t._v(" "),r("p",[t._v("通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice")]),t._v(" "),r("p",[t._v("切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上")]),t._v(" "),r("blockquote",[r("ol",{attrs:{start:"3"}},[r("li",[t._v("如何实现Aop?\nSpring AOP 确实是通过 CGLIB或者JDK代理 来动态地生成代理对象，这个代理对象指的就是 AOP 代理累，而 AOP 代理类的方法则通过在目标对象的切入点动态地织入增强处理，从而完成了对目标方法的增强")])])]),t._v(" "),r("blockquote",[r("p",[t._v("JDK动态代理只能为接口创建动态代理实例，而不能对类创建动态代理。需要获得被目标类的接口信息（应用Java的反射技术），生成一个实现了代理接口的动态代理类（字节码），再通过反射机制获得动态代理类的构造函数，利用构造函数生成动态代理类的实例对象，在调用具体方法前调用invokeHandler方法来处理。")])]),t._v(" "),r("blockquote",[r("p",[t._v("通过CGLIB动态代理实现上述功能并不要求目标对象拥有接口类，实际上CGLIB动态代理是通过继承的方式实现的，因此可以减少没必要的接口\n具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理")])]),t._v(" "),r("h3",{attrs:{id:"_4-aop执行流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-aop执行流程"}},[t._v("#")]),t._v(" 4. Aop执行流程")]),t._v(" "),r("ol",[r("li",[t._v("spring 容器启动,后在创建Bean后会执行后置处理,就会执行到AbstractAutoProxyCreator的postProcessAfterInitialization来判断是否需要代理")]),t._v(" "),r("li",[t._v("getAdvicesAndAdvisorsForBean，这个方法会提取当前bean 的所有增强方法，然后获取到适合的当前bean 的增强方法，然后对增强方法进行排序，最后返回")]),t._v(" "),r("li",[t._v("获取到当前bean的增强方法后，便调用createProxy方法，创建代理。先创建代理工厂proxyFactory，然后获取当前bean 的增强器advisors，把当前获取到的增强器添加到代理工厂proxyFactory，然后设置当前的代理工的代理目标对象为当前bean，最后根据配置创建JDK的动态代理工厂，或者CGLIB的动态代理工厂，然后返回proxyFactory")]),t._v(" "),r("li",[t._v("具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理")]),t._v(" "),r("li",[t._v("创建调用链,然后调用方法执行")])]),t._v(" "),r("h3",{attrs:{id:"事务方面的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事务方面的"}},[t._v("#")]),t._v(" 事务方面的")]),t._v(" "),r("p",[t._v("事务传播属性 : 一个方法运行在一个开启了事务的方法中,这个方法是使用原来的事务,还是开启一个新的事务\n7种类型的传播属性\nrequired 如果有事务用,没有事务就开启事务\nrequires_new 开启新事务")]),t._v(" "),r("p",[t._v("@Transactional")]),t._v(" "),r("h3",{attrs:{id:"_5-spring-mvc处理流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-spring-mvc处理流程"}},[t._v("#")]),t._v(" 5. Spring MVC处理流程")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("1.用户发送请求至前端控制器DispatcherServlet。")])]),t._v(" "),r("li",[r("p",[t._v("2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。")])]),t._v(" "),r("li",[r("p",[t._v("3.处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。")])]),t._v(" "),r("li",[r("p",[t._v("4.DispatcherServlet调用HandlerAdapter处理器适配器。")])]),t._v(" "),r("li",[r("ol",{attrs:{start:"5"}},[r("li",[t._v("HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。")])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"6"}},[r("li",[t._v("Controller执行完成返回ModelAndView。")])])]),t._v(" "),r("li",[r("p",[t._v("7.HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。")])]),t._v(" "),r("li",[r("p",[t._v("8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器。")])]),t._v(" "),r("li",[r("p",[t._v("9.ViewReslover解析后返回具体View。")])]),t._v(" "),r("li",[r("p",[t._v("10.DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。")])]),t._v(" "),r("li",[r("p",[t._v("11.DispatcherServlet响应用户。\nspringmvc中大量使用了模版方法模式。")])])]),t._v(" "),r("p",[t._v("https://www.cnblogs.com/fangjian0423/p/springMVC-directory-summary.html")])])}),[],!1,null,null,null);e.default=a.exports}}]);