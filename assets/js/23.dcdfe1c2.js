(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{153:function(t,s,a){"use strict";a.r(s);var e=a(0),_=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("这块面试被问到的比较少,准备比较少")])]),t._v(" "),a("h3",{attrs:{id:"_1-数据库的锁你了解多少"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据库的锁你了解多少"}},[t._v("#")]),t._v(" 1. 数据库的锁你了解多少")]),t._v(" "),a("blockquote",[a("p",[t._v("锁是数据库系统区分于文件系统的一个关键的特性,锁是用来管理对共享资源的并发访问,而对数据库来说数据就是数据库的资源,对于MyISAM是支持表级锁,而我们用InnoDB则是不支持表级锁,支持行锁,行级锁的特点是开销大,加锁时间长,会出现死锁,锁的粒度最小,发生锁的冲突的概率最低,并发度最高,对于MySql来说,主要有共享锁(读锁)和排他锁(写锁),锁的对象是事务,用来锁定数据库中的对象表、页、行.")])]),t._v(" "),a("h3",{attrs:{id:"_2-读锁-写锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-读锁-写锁"}},[t._v("#")]),t._v(" 2. 读锁 写锁")]),t._v(" "),a("blockquote",[a("p",[t._v("共享锁: 也叫读锁,可以让多个事务同时读取一行数据\n对于一行数据,不同事务可以同时获取读锁,但是在读取的过程中,其他事务是获取不到这行数据的写锁的,在写入这行数据的时候,在锁没有释放之前,其他事务拿不到该数据的读锁和写锁,对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据。")])]),t._v(" "),a("blockquote",[a("p",[t._v("排他锁: 也叫写锁,允许各种事务进行删除和修改\n当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。")])]),t._v(" "),a("h3",{attrs:{id:"_3-表级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-表级锁"}},[t._v("#")]),t._v(" 3. 表级锁")]),t._v(" "),a("p",[t._v("意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。\n意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁")]),t._v(" "),a("p",[t._v("这里为什么要提一下MyISAM就是要浪费时间,如果面试官问你对表级锁有了解吗,你就说我们公司用的是InnoDB(哈哈哈哈)")]),t._v(" "),a("h3",{attrs:{id:"_4-间隙锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-间隙锁"}},[t._v("#")]),t._v(" 4. 间隙锁")]),t._v(" "),a("blockquote",[a("p",[t._v("当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁")])]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v("  emp "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" empid "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("update")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁,\n在并发插入大于101 记录的时候,就会出现等待的情况(本不存在数据行被锁)\nInnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使 用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读")]),t._v(" "),a("h3",{attrs:{id:"_4-什么情况下会出现死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么情况下会出现死锁"}},[t._v("#")]),t._v(" 4. 什么情况下会出现死锁")]),t._v(" "),a("p",[t._v("这个问题还有一个问法就是 如何避免死锁")]),t._v(" "),a("blockquote",[a("p",[t._v("1.什么是死锁?")])]),t._v(" "),a("blockquote",[a("p",[t._v("首先说以下什么是死锁,死锁就是两个以上的事务在执行的过程中,由于抢占锁资源而导致的一种相互等待的现象,出现的情况就是\n在并发的过程中事务A拿到该记录的读锁在没有释放的情况下去获取该数据行的写锁,而事务B获取了该数据行的写锁,也在没有释放的情况下获取该数据行的读锁,这样就死锁了,解决的办法就是,等待一个事务释放锁,释放锁就需要事务回滚或是事务提交,、")])]),t._v(" "),a("blockquote",[a("p",[t._v("2.如何解决死锁")])]),t._v(" "),a("ul",[a("li",[t._v("尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；")]),t._v(" "),a("li",[t._v("选择合理的事务大小，小事务发生锁冲突的几率也更小；")]),t._v(" "),a("li",[t._v("给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；")]),t._v(" "),a("li",[t._v("不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；")]),t._v(" "),a("li",[t._v("尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响;不要申请超过实际需要的锁级别;除非必须，查询时不要显示加锁；")]),t._v(" "),a("li",[t._v("对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能")])]),t._v(" "),a("h4",{attrs:{id:"https-www-cnblogs-com-leedaily-p-8378779-html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https-www-cnblogs-com-leedaily-p-8378779-html"}},[t._v("#")]),t._v(" https://www.cnblogs.com/leedaily/p/8378779.html")]),t._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[t._v("InnoDB行锁是通过给索引上的索引项加锁来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！")])])])}),[],!1,null,null,null);s.default=_.exports}}]);