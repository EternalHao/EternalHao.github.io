(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{146:function(t,a,e){"use strict";e.r(a);var v=e(0),l=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("这块也是面试常问到的一块,需要研究")])]),t._v(" "),e("h3",{attrs:{id:"谈谈你所理解的java内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你所理解的java内存模型"}},[t._v("#")]),t._v(" 谈谈你所理解的Java内存模型")]),t._v(" "),e("blockquote",[e("ol",[e("li",[t._v("定义\n本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式,JMM是围绕原子性，有序性、可见性展开的,分为了主内存和工作内存,")])])]),t._v(" "),e("blockquote",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("存在的问题\nJVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见，这组规则也称为Java内存模型（即JMM），JMM是围绕着程序执行的原子性、有序性、可见性展开的")])])]),t._v(" "),e("p",[t._v("原子性: 操作是原子的,要么成功要么失败,")]),t._v(" "),e("p",[t._v("理解指令重排\n编译器优化的重排\n编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。")]),t._v(" "),e("p",[t._v("指令并行的重排")]),t._v(" "),e("p",[t._v("现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序\n处理器指令重排是对CPU的性能优化")]),t._v(" "),e("p",[t._v("内存系统的重排")]),t._v(" "),e("p",[t._v("可见性: 可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值")]),t._v(" "),e("blockquote",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("如何解决的问题")])])]),t._v(" "),e("p",[t._v("原子性\n除了JVM自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)保证程序执行的原子性")]),t._v(" "),e("p",[t._v("可以使用synchronized关键字或者volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。对于指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化")]),t._v(" "),e("p",[t._v("happens-before 原则")]),t._v(" "),e("h3",{attrs:{id:"volatile内存语义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile内存语义"}},[t._v("#")]),t._v(" volatile内存语义")]),t._v(" "),e("p",[t._v("保证被volatile修饰的共享gong’x变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总数可以被其他线程立即得知。")]),t._v(" "),e("p",[t._v("禁止指令重排序优化:")]),t._v(" "),e("p",[t._v("原理:\n当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中，当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。volatile变量正是通过这种写-读方式实现对其他线程可见")]),t._v(" "),e("p",[t._v("实现:\nvolatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，关于指令重排优化前面已详细分析过，这里主要简单说明一下volatile是如何实现禁止指令重排优化的。先了解一个概念，内存屏障(Memory Barrier）。")]),t._v(" "),e("h3",{attrs:{id:"sync"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sync"}},[t._v("#")]),t._v(" sync")]),t._v(" "),e("p",[t._v("造成线程安全问题的主要诱因有两点，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。因此为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块")]),t._v(" "),e("h1",{attrs:{id:"https-blog-csdn-net-beauxie-article-details-53013946"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https-blog-csdn-net-beauxie-article-details-53013946"}},[t._v("#")]),t._v(" https://blog.csdn.net/BeauXie/article/details/53013946")])])}),[],!1,null,null,null);a.default=l.exports}}]);